Microservices
	Architectural style where a software system is composed of multiple small automomous services that communicate over the network over well defined API's
	Make applications easier to scale,faster to develop, enabling innovation and accelerating time to market for new features. 
		Single responsibility principle--> Gather together things that change for the same reason and seperate those things that change for different reasons
		Focus service boundaries based on business boundaries
	Smaller the service more you maximize the benefits and downsides of microservice architecture
	The complexity emerges from having more and more moving parts
	All communication between services are via network calls to enforce seperation between services and avoid the perils of tight coupling
	Microservice may be deployed on a PaaS or may have its own operating system process
	These services need to be able to change independently of each other and be deployed by themselves without requiring consumers to change
	Think about what needs to be shown and what needs to be exposed,If there is too much sharing, our consuming services become coupled to our internal representations. This
    decreases our autonomy, as it requires additional coordination with consumers when making changes.
	Our service exposes an application programming interface (API), and collaborating services communicate with us via those APIs. We also need to think about what
    technology is appropriate to ensure that this itself doesn’t couple consumers. This may mean picking technology-agnostic APIs to ensure that we don’t constrain technology
    choices. 
	To do decoupling well, you’ll need to model your services right and get the APIs right
	With microservices adopt technology more quickly and understand how new adoptions may help us 
	Technological heterogeniety
		With a system composed of multiple collaborating services, we can decide to use different technologies inside each one
		This allows us to pick the right tech stack for the right job rather than to having a standardized one size fits all approach
		If one part of our system needs to improve its performance, we might decide to use a
		different technology stack that is better able to achieve the performance levels required.We may also decide that how we store our data needs to change for different 
		parts of our system. For example, for a social network, we might store our users’ interactions in a graph-oriented database to reflect the highly interconnected nature of a social graph, but perhaps the posts the users make could be stored in a document-oriented data store, giving rise to a heterogeneous architecture
		
		With microservices, we are also able to adopt technology more quickly, and understand how new advancements may help us. One of the biggest barriers to trying out and
		adopting new technology is the risks associated with it. With a monolithic application, if I want to try a new programming language, database, or framework, any change will impact a large amount of my system. With a system consisting of multiple s	ervices, I have multiple new places in which to try out a new piece of technology. I can pick a service that is perhaps lowest risk and use the technology there, knowing that I can limit any potential negative impact. Many organizations find this ability to more quickly absorb new technologies to be a real advantage for them.
		If you can rewrite your microservice in 2 weeks you may mitigate the risks of embracing new technology
	Resilence:
		if one system fails and doesnt cascade, you can isolate the problem and rest of the system can carry on working
		With a monolithic service, if 
	Scaling on demand for those pieces who need it	

	
Spring Microservices (Spring boot version 3.0.6)
	
Web service
	Service delivered over the web
	Interoperability
	Without web service we need to use Jar (to provide business logic to another application)
	Software system designed to support interoperable machine to machine interaction over a network
		Designed for application to application interaction(machine to machine)
		Should be platform independent(interoperable).. Other applications installed using Java, Dotnet or PHP
		Should allow communication over a network
	Popular formats for request and response
		XML(Extensible markup language)
		Json	
	Every web service offers a service definition that the applications who are going to use web service are provided with. Service definition is the contract 
	(Service provide provides WSDL to Service consumer)
		a) request and response format (JSON/XML)
		b) Structure of the request and Response
		c) endpoint of the service
		
	Transport defines how a service is called. It can be exposed over rt
			- HTTP and MQ (service exposed over internet- HTTP or over a queue-MQ)
			- Just how you type the URL in browser, same way an application will call the web service
			- Service requestor will place the message on queue, Service provider will be listening on the queue, do the processing, create the response and put it back
			  on the queue
			  
	
SOAP web services (Simple Object Access Protocol) 
	Defines a specific way of building services
	XML is used as the request and response exchange format
	SOAP defines a specific request and response structure	
	SOAP envelope (header(optional)->authentication, authorisation) +body
	You have to adhere to the above format SOAP XML structure
	
SOAP does not pose any restrictions on your transport	
	Use HTTP or MQ
	Service definition is done using WSDL
	
REST( Representational state transfer)- Architectural approach
	HTTP is a protocol which is used to browse and access the web
	Rest is Based on HTTP, Make best use of HTTP to develop web services as well
	Most important abstraction in REST is called Resource, a resource is anything that you want to expose to the outside world through your application
	A resource is a URI	user/saurabh/todos/1 -> a resource can have different representations XML,HTTP,JSON
		create a user do a POST /users
		delete user 1 do a delete /user/1
		get all users do a get /users
		Get one user do a get/user/one	
	When you type URL in browser, sends a get request to the webserver, server sends the HTTP response containing the HTML which is rendered on your browser
	HTTP defines the header and the body of the request
	HTTP also defines something called request methods.
	You can indicate what action you are doing by using the HTTP request methods.
	Get, I'm trying to get the details of something, Post, I'm trying to create something, Put, I'm trying to update something.
	A HTTP response will also include a HTTP status code
	Rest has no restriction on data format(Json is popular)...transport is always over HTTP.. there is no standard service definition or service definition language
	WADL/Swagger.. (one of the formats to specify)
	RESTful services are easier to implement than SOAP
	
Soap VS REST
	Not an apple to apple comparison, SOAP is restrictions, REST is architectural approach
		
Garbage
@RestController for controller class
	@RequestMapping("api/order")
    @PostMapping
		  private final OrderService orderService;
		  public String placeOrder(@RequestBody OrderRequest orderRequest){
				return orderService.placeOrder (orderRequest);
		 }
	http://localhost:8080/courses
	One class has @SpringBootApplication annotation..that class has to be outside//other classes can be in subpackages
	RestfulWebServiceApplication
	SpringApplication.run(RestfulWebServiceApplication.class, args);
	Instead of @RequestMapping(method= RequestMethod.GET) you can use @GetMapping(path="/courses")
	Maven use Bundled Maven 3

Spring boot vs Spring MVC vs Spring
	Conventional Spring
		1)Dependency Management - for rest API you would need spring framework, spring MVC framework, JSON binding framework.. For spring- Spring test, Mockito, JUnit
			Create a pom.xml with all dependencies and versions
		2) web.xml (Web app configuration)
			Configure Dispatcher Servlet for Spring MVC
		3)Component scan and view resolver , define a data source  manage spring beans..context.xml
		4) NFR's logging, error handling, monitoring
	Repeat this for every project
	Spring Boot makes it easy
		
Spring Boot--
	Help you build production ready apps quickly-- Goal of Spring boot
	Spring Initializer is a web application that helps you to create an initial spring boot project structure and provides a maven or gradle file to build your code. It solves the problem of setting up a framework when you are starting a project from scratch.
	Spring initializr: start.spring.io
	Snapshots are the developing versions->A Snapshot version is a work-in-progress version of a software release that is not yet stable
	Add dependency, group, artifact name, download zip, import intellij and start	
	
Spring Boot- Starter projects
	Spring boot starter projects are predefined dependency templates that bundle the necessary transitive dependencies that are needed to enable a particular functionality in your spring boot application
	Simplifies dependency management – No need to manually add multiple dependencies;
	Instead of managing dozens of dependencies manually, you only need one starter dependency for each feature you need.	
	
	Convenient dependency descriptors for different features
	For creating web application
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		
		This spring-boot-starter-web starter automatically includes dependencies for:Spring MVC,Tomcat (embedded server),Jackson (JSON processing)
		
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
	
	Spring boot provides a variety of starter projects depending on what kind of application you are designing	
	
	spring-boot-starter-web			For building web applications (Spring MVC, REST, Tomcat)
	spring-boot-starter-data-jpa	For database access using Spring Data JPA
	spring-boot-starter-security	Adds Spring Security for authentication & authorization
	spring-boot-starter-test		Includes JUnit, Mockito, and other testing tools
	spring-boot-starter-actuator	Provides production-ready monitoring & metrics
	
Spring Boot- Auto configuration	
	Spring Boot Auto-Configuration automatically configures your application based on the dependencies present on the classpath and the existing configuration (annotations, properties, etc.)
	Eliminate need for manual Configuration to setup Spring, Spring MVC and other frameworks	
	Auto-configuration is enabled through the spring-boot-autoconfigure JAR.
	Use the /actuator/conditions endpoint (if Actuator is enabled) to see:
	Positive Matches (auto-configured components).
	Negative Matches (not configured due to missing dependencies).
			
			
	If you define a @Bean for a specific component, Spring Boot will use your bean instead of the auto-configured one
	@Bean
	public DataSource customDataSource() {
		return new HikariDataSource();
	}
	
	Use @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class }) to prevent unwanted configurations:
	@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })
	public class MyApplication { }

	Selectively Enable/Disable Features in application.properties	
	spring.datasource.url=jdbc:mysql://localhost:3306/mydb
	spring.datasource.username=root
	spring.datasource.password=secret
	
	You can use exclude attribute of @EnableAutoConfiguration if you want auto-configuration not to apply to any specific class.
	//use of exclude
	@EnableAutoConfiguration(exclude={className})

	
	You can define both application and Spring boot-related properties into a file called application.properties. You can create this file manually or use Spring Initializer to create this file. You don’t need to do any special configuration to instruct Spring Boot to load this file, If it exists in classpath then spring boot automatically loads it and configure itself and the application code accordingly
	
Debugging logs can be enabled in three ways -
	We can start the application with --debug switch.
		java -jar myapp.jar --debug
	We can set the logging.level.root=debug property in application.properties
	We can set the logging level of the root logger to debug in the supplied logging configuration file.
	If you provide a custom logging configuration file (such as logback.xml for Logback or log4j2.xml for Log4j2), you can set the root logger's level to debug within that file.
	TRACE->DEBUG->INFO->WARN->ERROR
	
Application-context
	1️)Annotation-Based Configuration (Modern Approach)
	2)XML-Based Configuration (Legacy Approach)
	No, Spring Boot won't load an XML configuration file like application-context.xml automatically unless you explicitly instruct it to do so. By default, Spring Boot favors annotation-based configuration and auto-configuration, so if you want to include an XML file, you'll need to use the @ImportResource annotation in your main application class:	
	
	@SpringBootApplication
	@ImportResource("classpath:application-context.xml")
	public class MySpringBootApplication {
		public static void main(String[] args) {
			SpringApplication.run(MySpringBootApplication.class, args);
		}
	}
	
Why is XML Configuration Less Popular Now?
	More complex than annotations.
	Harder to maintain (large XML files).
	Not as flexible as annotation-based configuration.
	Still useful when integrating legacy applications.
	
6. What does the @SpringBootApplication annotation do internally?
	In Spring Boot, automatic component scanning is one of the key features that simplifies application setup and management. By default, Spring Boot uses the @SpringBootApplication annotation, which is a combination of several annotations, including @ComponentScan.

	This annotation is typically used on the main class of the application (the class containing the main method).
	It includes @EnableAutoConfiguration, @ComponentScan, and @Configuration.
	The @ComponentScan annotation automatically scans the current package and its sub-packages for components like @Component, @Service, @Repository, and @Controller.
	
	@ComponentScan
	This annotation is responsible for finding and registering all Spring beans (components) defined with annotations like @Component, @Service, @Repository, and @Controller.
	By default, @ComponentScan will scan the package where the main Spring Boot application class is located and its sub-packages.
	
	
	You only need to explicitly add @ComponentScan if:
	You want to change the default scanning behavior (e.g., scan additional packages or exclude certain packages).
	Your components are located outside the base package of your main application class, and you want to scan other packages.
	
	Automatic discovery: No need to manually register beans in configuration files.
	Simplified setup: Just use the correct annotations, and Spring Boot handles the rest.
	Loose coupling: Encourages a modular, decoupled structure for the application.
	
Spring Boot Dev Tools
	Setup for IntelliJ
	https://stackoverflow.com/questions/33869606/intellij-15-springboot-devtools-livereload-not-working			
	Increased developer productivity
	Why do you need to restart manually for every code change?
		<dependency>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-devtools</artifactId>
		</dependency>	
	
	If you are making changes to pom.xml, then you have to restart the application manually	
	
Spring Boot-Profiles
	While developing an application we deal with multiple environments such as dev, QA, Prod, and each environment requires a different configuration. For eg., we might be using an embedded H2 database for dev but for prod, we might have proprietary Oracle or DB2. 
	Spring has the provision of Profiles to keep the separate configuration of environments.
	Enables you to specify environment specific configuration
	Create a specific profile for each different environment(configuration)
	application.properties..create seperate file for each environment application-dev.properties
	1) Go to application.properties and set active profiles
		spring.profiles.active=dev
	The dev profile will now supersede the property in the default profile for the application
	2) Using JVM Parameters
		-Dspring.profiles.active=dev
	
	Spring Boot- Configuration Profiles
		See demo 
		Centralized class for the application related configuration
	A combination of configuration properties and profiles in spring boot is powerful, externalize all configuration needed for your application
	
	
1) Configuration Profiles (Properties/YAML Files):
	What They Do:
	These files (like application.properties, application-dev.properties, or sections in application.yml) hold your environment-specific configuration settings.They provide the actual configuration values (e.g., database URLs, usernames, passwords, etc.) for different environments (development, production, etc.).
2. Centralized Configuration Class (using @ConfigurationProperties):
	What It Does:
	This is a Java class that is used to map the configuration properties from your files into a structured object that you can easily use in your code.It acts as a central point of access for all those configuration values. With this class, you can simply inject it into other parts of your application and refer to the properties directly (instead of repeatedly reading from the properties file).
How They Work Together:
Loading the Values:
When you start your Spring Boot application, Spring Boot reads the configuration files (taking into account the active profile) and loads all the defined properties.
Binding to the Class:
The centralized configuration class, annotated with @ConfigurationProperties(prefix = "app") (or any prefix you choose), is automatically populated with the values from those configuration files.
Usage:
Your code then simply uses the centralized configuration class to access these values. This approach keeps your configuration organized and easily manageable.
Example Flow:
Define Environment-Specific Configurations:
You have an application.yml that includes a common section and environment-specific sections (e.g., dev, prod).
Centralized Configuration Class:
You create a class like AppConfig that is annotated with @ConfigurationProperties(prefix = "app").
Spring Boot Bootstraps:
Spring Boot reads the application.yml based on the active profile (say, dev).
It then binds the values under the app prefix to your AppConfig class.
Access in Your Application:
You inject AppConfig into your controllers or services and use the values as needed.

spring:
  profiles:
    active: dev  # This line sets the active profile

# Default settings for all profiles
app:
  name: MySpringBootApp
  description: Default Application Configuration

---
spring:
  profiles: dev
app:
  datasource:
    url: jdbc:mysql://localhost:3306/devdb
    username: devuser
    password: devpass

---
spring:
  profiles: prod
app:
  datasource:
    url: jdbc:mysql://prodserver:3306/proddb
    username: produser
    password: prodpass


import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConfigurationProperties(prefix = "app")
public class AppConfig {

    private String name;
    private String description;
    private DataSourceProperties datasource;

    // Getters and setters

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public DataSourceProperties getDatasource() {
        return datasource;
    }

    public void setDatasource(DataSourceProperties datasource) {
        this.datasource = datasource;
    }

    // Nested class for datasource properties
    public static class DataSourceProperties {
        private String url;
        private String username;
        private String password;

        // Getters and setters
        public String getUrl() {
            return url;
        }

        public void setUrl(String url) {
            this.url = url;
        }

        public String getUsername() {
            return username;
        }

        public void setUsername(String username) {
            this.username = username;
        }

        public String getPassword() {
            return password;
        }

        public void setPassword(String password) {
            this.password = password;
        }
    }
}

How to Use the Configuration:

Anywhere in your Spring Boot application, you can inject AppConfig to access these properties:

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class AppController {

    @Autowired
    private AppConfig appConfig;

    @GetMapping("/app-info")
    public String getAppInfo() {
        return "App Name: " + appConfig.getName() + ", Description: " + appConfig.getDescription()
            + ", DB URL: " + appConfig.getDatasource().getUrl();
    }
}


Spring Boot embedded server
	Old ways of deploy 1) Install Java 2) Install tomcat 3)Deploy War(Web archive)
	Embedded server is simpler alternative, the server(tomcat) is already part of your jar file
	Install java and run your jar file
	C:\Users\saura\repo\learn-spring-boot\target\learn-spring-boot-0.0.1-SNAPSHOT.jar
	Just run the jar (tomcat is part of our jar)
	It simplifies the deployment process
	Default is starter-tomcat(jetty,undertow is also supported)
	Yes, we can replace the Embedded Tomcat server with any server by using the Starter dependency in the pom.xml file. Like you can use spring-boot-starter-jetty as a dependency for using a jetty server in your project.
	
	Can we disable the default web server in the Spring boot application?
	Yes, we can use application.properties to configure the web application type i.e spring.main.web-application-type=none.
	
	The default port of the tomcat server-id 8080. It can be changed by adding sever.port properties in the application.properties file.
	
	In Gradle, the equivalent to a pom.xml file (used in Maven) is the build.gradle file. Both files define the project's build configuration, dependencies, plugins, and other tasks, but the structure and syntax differ between Maven (XML) and Gradle (Groovy or Kotlin DSL).

	
Spring Boot Actuator
	Monitor and manage your application in production
	Provides a number of endpoints
		/actuator/beans: Complete list of Spring beans in your application.
		/actuator/health: Application health information.
		/actuator/metrics: Application metrics.
		/actuator/mappings: Details about request mappings.
		<dependency>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>		
	
	To expose all endpoints or specific ones, configure it in application.properties:
	
	management.endpoints.web.exposure.include=*
	Alternatively, you can specify individual endpoints like:
	management.endpoints.web.exposure.include=health,metrics
	
	To view HTTP request metrics:
	http.server.requests
	http://localhost:8080/actuator/metrics/http.server.requests
	Provides a lot of information about the application and the environment in which your application is running
	
	
	The /actuator/env endpoint in Spring Boot Actuator provides access to the environment properties of the application. This includes:
	System properties (e.g., Java version, operating system details)
	Environment variables (e.g., PATH, USER, etc.)
	Application properties (e.g., properties defined in application.properties or application.yml)
	Configurable properties (e.g., values for @Value annotations)
	In short, this endpoint gives a detailed view of the current environment configuration of your Spring Boot application, making it useful for debugging or inspecting the settings that affect your application during runtime

Spring automatically detects components when you use annotations like @Component, @Service, or @Repository. But sometimes, you don’t want automatic scanning and need more control over bean creation.

Example situations where you might use @Bean:
	When dealing with third-party classes that don’t have @Component annotations.
	When you want to customize bean creation with specific logic.
	When you want manual control over dependencies.

import org.springframework.stereotype.Component;

@Component
public class Car {
    public void drive() {
        System.out.println("Driving a car!");
    }
}

ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
Car car = context.getBean(Car.class);
car.drive();  // Output: Driving a car!


Now, let’s say Car does not have @Component, but you still want Spring to manage it.

public class Car {
    private String model;

    public Car(String model) {
        this.model = model;
    }

    public void drive() {
        System.out.println("Driving a " + model);
    }
}

//error
ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
Car car = context.getBean(Car.class);
car.drive();  // Output: Driving a car!

Since Car is just a normal Java class, Spring won’t detect it automatically.

So, we manually register it using @Bean inside a @Configuration class:

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration  // This class defines beans manually
public class AppConfig {

    @Bean  // This method tells Spring: "Hey, create and manage this bean!"
	//create a method returning this class
    public Car myCar() {
        return new Car("Tesla Model S");
    }
}

//now works
ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
Car car = context.getBean(Car.class);
car.drive();  // Output: Driving a tesla model S!

When Should You Use @Bean?
	For third-party libraries (e.g., database connections, API clients).
	When you need to customize bean creation (e.g., setting properties dynamically).
	When the class doesn’t have @Component but you still want Spring to manage it.


Imagine you are working on a Spring Boot application that needs to connect to a MySQL database.

Usually, you can define database configurations in application.properties, but sometimes, you might want to manually configure the database connection using Java code.

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import javax.sql.DataSource;
import org.apache.commons.dbcp2.BasicDataSource;

@Configuration  // Marks this class as a configuration provider
public class DatabaseConfig {

    @Bean  // Manually defining a DataSource bean
    public DataSource getDataSource() {
        BasicDataSource dataSource = new BasicDataSource();
        dataSource.setUrl("jdbc:mysql://localhost:3306/mydb");
        dataSource.setUsername("root");
        dataSource.setPassword("password");
        dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
        return dataSource;
    }
}

Why Use @Bean Here?

The BasicDataSource class (from Apache Commons DBCP) is a third-party class, so we can't use @Component.
We need to set some properties (URL, username, password, etc.) before returning the object.

//Now, let’s use constructor injection to get this bean inside a service.

import org.springframework.stereotype.Service;
import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.SQLException;

@Service
public class DatabaseService {

    private final DataSource dataSource;

    public DatabaseService(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    public void testConnection() {
        try (Connection connection = dataSource.getConnection()) {
            System.out.println("✅ Database connected successfully!");
        } catch (SQLException e) {
            System.out.println("❌ Failed to connect to database: " + e.getMessage());
        }
    }
}


Spring boot vs spring mvs vs Spring

		Spring framework is about dependency injection, Identifying the dependencies @Component,@Service, @Autowired, Component scan-- identify all components
			Spring modules and spring projects extend the spring eco system ..provide good integration with other frameworks (Hibernate/JPA, Junit, Mockito	)
		Spring MVC is a spring module ->Only focus on Simplify building wep apps and rest api
			@Controller, @RequestMapping, @RestController
		SpringBoot (Wrapper that makes it easy to use Spring MVC and Spring)
			To build production ready apps quickly
				Starter projects easy to build wide variety of applications
				Eliminate Configuration to setup Spring, Spring MVC and other frameworks. 
				Default conf based on what is in your classpath
				Enable non functional requirements
					Actuator-> enables advanced monitoring of application
					Embedded Server-> No need for seperate application servers
					Logging and error handling
					Profiles and Configuration properties
					
Section 3 -Advanced rest services
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>

		<dependency>
			<groupId>com.h2database</groupId>
			<artifactId>h2</artifactId>
			<scope>runtime</scope>
		</dependency>				
		
	All requests are handled by dispatcher servlet in Spring MVC
	Mapped to the root URL
	All respects irrespective of URL first come her
	Dispatches to the right controller
	Spring AutoConfiguration configures dispatcher servlet	
	How the return object is converted to Json?
		@ResponseBody+JacksonHttpMessageConverters
		@RestController has @response body and is saying return the bean as is and there will be conversion happening
		Default conversion is using JacksonHttpMessageConvertersConfiguration auto configured by SpringAutoConfiguration
	Configuring error mapping-> If you try to access a resource that does not exist (ErrorMVCAutoConfiguration)
	How are all jars available? Because of starter projects..they come in your classpath and then SpringBeanAutoConfiguration does rest of the magic
		
		
		
		
		
		
Microservices
	Its an architectural style to develop single application as a suite of small services, each running its own process
	Small autonomous services that work together
	Microservices are services exposed by REST
	Small well chosen deployed units with very well thought out boundaries
	Which are cloud enabled	Meaning -There can multiple instances for each of these microservices..using a container orchestration you can bring them up or down
	
Challenges with microservices
	Deciding the boundary of the microservice is an evolutionary process-->Need to have proper business knowledge
	Configuration management--> multiple instances of multiple microservices with multiple environments.. how to manage the several configurations?
	Dynamic scale up and scale down
	Visiblity->Identify where the bug is.. centralized log..which microservice is problem..Also need monitoring to see micro-services are up or down
			   All monitoring needs to be automated
	Microservices communicate with each other// if one goes down other shouldnt..so we need fault tolerance	->How do we build fault tolerance in microservices
	
SpringCloud
	
	SpringCloudConfigurationServer(Configuration management)
		Provides an approach where you can store all configuration of all different env of all different microservices in a centralized location (gi repository)
		SpringCloudConfigServer exposes that configuration to all microservices, keep all configuration in one place, makes it easy to manage
	Naming Server(Eureka)
	Service Registration and Discovery->	All instances of microservices will be registered against Eureka (naming Server )
		Currency calculation service should ask the naming server, give me all the instances who are running the currency exchange service
			and the naming server will provide that informations
	Ribbon(Dynamic scale up and scale down)
		Dynamically adjust as per load (distribute the load as per instances)
		Load is evenly distributed for the existing instances it gets from the naming server		
	Feign
		Write simple restful clients
	Zipkin Distributed Tracing (visibility and monitoring)
		We would use Spring Cloud Sleuth to assign a ID to a request across multiple components and we would use Zipkin Distributed Tracing
		to trace a request across multiple components.
	API gateways (Netflix Zuul API gateway)
		Logging, Security, Analytics and things like that (for all microservices)
	Fault Tolerance (Hystrix)	
		if a service is down, Hystrix helps to configure a default response
		
Advantages
	It allows you to adapt new technology and processes very easily
		Each microservices can be built in different technologies
		In Monolith applications we would not have that flexibility
		Microservice 1 may be java, microservice 2 may be NodeJs
	Dynamic Scaling
		If your microservices are cloud enabled they can scale dynamically and you can procure hardware and release it dynamically as well
		Scale them up and down as per your load
	Faster release cycles	
		Because you are developing smaller components easier to release microservices as compared to monolith applications
		Faster release cycles..bring new features faster to market

Standardizing Ports & URL
	Set up at least 7 projects
		Limits service 8080,8081
		Spring cloud config server 8888
		Currency exchange service 8000,8001,8002
		Netflix Eureka Naming Server 8761
		Netfliz Zuul API gateway server 8765
		Zipkin Distributing Tracing Server 9411
		https://github.com/in28minutes/spring-microservices/tree/master/03.microservices
		All URL's that are used in this course
		
V2
	SpringCloudLoadBalancer(instead of ribbon)
	SpringCloudGateway instead of Zuul
	Resilience4j instead of Hystrix

# Architecture
Limits microservice  Microservice X   Microservice Y
		\					/			/
		Spring Cloud Config Server
				\	
				Git Repo

	
#Create a LimitsMicroService		
	Config client -> Client that connects to spring cloud config server
	<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-config</artifactId>
	</dependency>
	Configure how spring cloud starter config needs to connect to spring cloud server..
	In application.properties
	spring.config.import=configserver:http://localhost:8888
	spring.config.import=optional:configserver:http://localhost:8888
	If you want to make the connection to config server mandatory, you can remove the optional
	limits-service.minimum=2
	limits-service.maximum=999
	
https://github.com/in28minutes/spring-microservices-v3/blob/main/03.microservices/01-step-by-step-changes/readme.md#spring-cloud-config-server---steps-01-to-08
	Step 04 - Setting up Spring Cloud Config Server


	
	
#Create a Git repository	
	Step 05 - Installing Git and Creating Local Git Repository
	/git-spring-boot-localconfig-repo
git-localconfig-repo/limits-service.properties New
	limits-service.minimum=4
	limits-service.maximum=996
	


#Create a config server	(Spring cloud config server connected to git repository)
On Spring Initializr, choose:
	Group Id: com.in28minutes.microservices
	Artifact Id: spring-cloud-config-server
	Dependencies
	DevTools
	Config Server
	
	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-config-server</artifactId>
	</dependency>	
	
	@EnableConfigServer
	Also in application.properties
	spring.application.name=spring-cloud-config-server
	server.port=8888	
	spring.cloud.config.server.git.uri=file:///C:/Users/saura/repo/git-spring-boot-localconfig-repo
	spring.cloud.config.server.git.default-label=main (otherwise it looks in master)

Run the URL
	http://localhost:8888/limits-service/default
	
#Connect limits microservice to Spring Cloud Config Server
	spring.config.import=optional:configserver:http://localhost:8888	
	spring.application.name=limits-service (from git repo)
	http://localhost:8080/limits will give values from git repo
	When limits service start it executes the URL on cloud config server  http://localhost:8088/limits-service/default 	and get the config back

	Starting LearnSpringBootApplication using Java 17.0.1 with PID 46580 (C:\Users\saura\repo\learn-spring-boot\target\classes started by saura in C:\Users\saura\repo\learn-spring-boot)
	The following 1 profile is active: "prod"
	Fetching config from server at : http://localhost:8888

	http://localhost:8888/limits-service/qa
	http://localhost:8888/limits-service/default

	{"name":"limits-service","profiles":["qa"],"label":null,"version":"6dc2bf5235c3838010ef66a1d7028e6ab0f2618b","state":null,"propertySources":[{"name":"file:///C:/Users/saura/repo/git-spring-boot-localconfig-repo/limits-service-qa.properties","source":{"limits-service.minimum":"8","limits-service.maximum":"992"}},{"name":"file:///C:/Users/saura/repo/git-spring-boot-localconfig-repo/limits-service.properties","source":{"limits-service.minimum":"4","limits-service.maximum":"996"}}]}

	Priority with environment and second value is default

	Use this spring.profiles.active=prod
	OR
	spring.cloud.config.profile=dev
	spring.cloud.config.name?

	For another microservice.. create properties file such as microservice-x-dev.properties and so on and so forth
	So all configuration related to your application is centralized at one place..is centralized
	By seperating out your configuration from your application, you are making operations easier.. 
	Control All configurations for all microservices in all environments in a single location (git repository)		

#Debugging guide
	https://github.com/in28minutes/spring-microservices-v3/blob/main/03.microservices/01-step-by-step-changes/readme.md#spring-cloud-config-server---steps-01-to-08
	
#CurrencyExchangeServiceApplication
	spring.application.name=currency-exchange
	server.port=8000
	spring.config.import=optional:configserver:
	http://localhost:8000/currency-exchange/from/USD/to/INR
	
#Having 2 instances of the same application 
	Copy run configuration, provide VM arguments
	-Dserver.port=8001
	Whatever you provide in VM properties will override whatever is configured in application.properties
	Will launch up a new instance
	http://localhost:8001/currency-exchange/from/USD/to/INR
	You can identify which instance is being called
		
#JPA
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-data-jpa</artifactId>
	</dependency>	

	<dependency>
		<groupId>com.h2database</groupId>
		<artifactId>h2</artifactId>
	</dependency>
	h2 in memory database
	
	in application.properties
		spring.jpa.show-sql=true   				 (to see all SQL statements that are generated)
		spring.datasource.url=jdbc:h2:mem:testdb (otherwise you get a random database url)
		spring.h2.console.enabled=true			 (see details present in the database)
		
	When you run you see h2 console
		http://localhost:8000/h2-console/
		
	#Spring Data JPA	
		In your bean add @Entity and @Id for your primary key...h2 will automatically create tables
		If you want to have different column names than the bean use @Column(name="currency_from")	
		tables and columns are automatically created with the _ wherever there is space
		@Table if you want a different table name
		@Id,@SequenceGenerator if you want to generate sequences
		@Transient for columns you do not want to be a part of database
		Fields marked with @Transient are ignored and not mapped to any database column (in RDBMS)		
	#JPARepository
	#How to connect Service to in memory database
		public interface StudentRepository extends JpaRepository<Student,Long> {
		Student findById(int id);
		Student findByName(String name);
		}
		 //jpql
		//@Query("SELECT s from Student s where s.email=?1")
		 Student findByEmail(String email);
		 Question#: When would we need JPQL?
	#LoadData
		Create data.sql file parallel to application.properties with the insert queries
			INSERT INTO STUDENT (ID,NAME,EMAIL,DATE_OF_BIRTH,AGE) values (2,'Shyam','shyam@infy.com','1990-12-22',33)
		It gets loaded automatically before the tables are created..to prevent this use defer property in application.properties
		spring.jpa.defer-datasource-initialization=true
	#Another way	
	@Configuration
	public class StudentConfig {
		@Bean
		CommandLineRunner commandLineRunner(StudentRepository studentRepository){
			return args -> {
				Student alex=new Student(1L,"Alex","alex@gmail.com", LocalDate.of(2001, Month.JULY,23));
				Student ronya=new Student(3L,"Ronya","ronya@gmail.com",LocalDate.of(1995, Month.JULY,02));
				studentRepository.saveAll(List.of(alex,ronya));
			};

		}
		#to avoid multiple loads everytime you run
			spring.jpa.hibernate.ddl-auto=create-drop
		In production use none	
			spring.jpa.hibernate.ddl-auto=none
			
CRUD operations - Spring boot rest API structure			
	#How the controller will call the data
		@GetMapping("/api/v1/student/{id}") 
		public Student getStudent(@PathVariable int id){
        return studentService.getStudent(id);
    }
	
	Service Layer
	public Student getStudent(int id) {
		return studentRepository.findById(id)
			.orElseThrow(() -> new IllegalStateException("Student not found"));
	}	
		
 #Post is used when you want to add new resources, accepts Json RequestBody
	Controller:
	  @PostMapping("/api/v1/register")
		public void registerNewStudent(@RequestBody Student student){
        studentService.addNewStudent(student);
		}
	Service
		public void addNewStudent(Student student) {
        Optional<Student> studentOptional=studentRepository.findByEmail(student.getEmail());
        if(studentOptional.isPresent())
            throw new IllegalStateException("email taken");
        studentRepository.save(student);
        System.out.println(student);
    }
POST:http://localhost:8080/api/v1/register			
		{
		"id": 5,
		"name": "Prakash",
		"email": "prakash@gmail.com",
		"dateOfBirth": "2011-07-23"
		}		
First time succeeds
Second time
{
    "timestamp": "2023-06-29T14:47:34.916+00:00",
    "status": 500,
    "error": "Internal Server Error",
    "message": "email taken",
    "path": "/api/v1/register"
}		

For message to be displayed use property: server.error.include-message=always in application.properties

Delete: http://localhost:8080/api/v1/delete/5
Controller
@DeleteMapping("/api/v1/delete/{id}")
    public void deleteStudent(@PathVariable Long id){
        studentService.deleteStudent(id);
    }
Service
 public void deleteStudent(Long id) {
        boolean exists=studentRepository.existsById(id);
        if(!exists)
            throw new IllegalStateException("Student does not exist");
        studentRepository.deleteById(id);
    }
	
PUT
Update name/email
    @PutMapping("/api/v1/update/{id}")

@Transactional means you dont have to implement any jpql query		
public void updateStudent(@PathVariable Long id,
                          @RequestParam(required = false) String name,
                          @RequestParam (required=false) String email){
        studentService.updateStudent(id,name,email);
    }
	
PUT http://localhost:8080/api/v1/update/5?name=Rajesh&email=rajesh@gmail.com

@PathVariable in Spring Boot
	@PathVariable is an annotation in Spring Boot that extracts values from URL path parameters and binds them to method parameters in a REST controller.

	The {id} in @GetMapping("/student/{id}") acts as a placeholder in the URL.
	@PathVariable int id automatically extracts the value from the URL and assigns it to the method parameter id.	

	@GetMapping("/student/{id}/{name}")
	public String getStudent(@PathVariable int id, @PathVariable String name) {
		return "Student ID: " + id + ", Name: " + name;
	}
	GET http://localhost:8080/api/v1/student/10/John
	
	@GetMapping("/student/{studentId}")
	public String getStudent(@PathVariable("studentId") int id) {
    return "Student ID: " + id;
	}
	GET http://localhost:8080/api/v1/student/7

	@GetMapping("/student")
	public String getStudent(@RequestParam int id) {
    return "Student ID: " + id;
}
	GET http://localhost:8080/student?id=5
	
	Use @PathVariable when the parameter is part of the URL path (e.g., /users/123).
	Use @RequestParam when the parameter is optional or part of a query string (e.g., /users?age=30).
	

@RestController = @Controller + @ResponseBody
	The @RestController annotation in Spring Boot is a specialized version of @Controller, designed specifically for RESTful web services. It is a combination of:

	@Controller → Indicates that the class is a Spring MVC controller.
	@ResponseBody → Automatically serializes the return values of methods into JSON or XML and writes them to the HTTP response body.
	Automatically converts Java objects to JSON/XML.
	Used for creating RESTful APIs, not for rendering views.
	Eliminates the need for @ResponseBody on each method.

	@Controller ->For handling HTML views (like JSP, Thymeleaf)


#mvn clean then install will create demo snapshot jar
java -jar (name of jar) --server.port=8081
To run into another port



Youtube video		
@GetMapping for method
@RequestMapping for controller
create a final instance of service with constructor
@Autowire it

@Service in the service layer

Spring-----------------
	Inversion of control --> give control to framework itself, no need to create objects yourself.. Spring allows dependency injection
	 (define spring.xml and load it in main method using ClassPathXMLApplicationContext)
		XML based injection
			Constructor based injection (define constructor arg in xml)
			Getter Setter based injection(property,ref for object, value for value in xml)
				Use context.getBean(Doctor.class or "id")
		Annotation based injection	
			Give context component scan base package in context.xml
			Use @Component for classes that need to be injected (its a stereotype Component)
		Java Configuration Way
			Application context= new AnnotationConfigApplicationContext(BeanConfig.class)
			BeanConfig class have @Configuration, @ComponentScan(basePackage="demo"))
			OR
			@Bean define your bean..and return
		5 different types of scope	
			Use @Scope(scopeName="prototype")
			Singleton(Default)
				One object is created in entire application
					No matter how many times you get object from context.get(Doctor.class) you will get the same object
			,Prototype
				New object on request from each container
			,Request,
				Create a new object for every request..used in web container
			Session,Global Session
			Paused at 47:00
	Aspect Oriented Programming--> Logging user data, securities, Cross cutting concerns seperate out using AOP.. invoke those particular methods for every request
	Spring provides data libraries/projects for every type of data source
#SpringBoot
	Build production ready apps quickly
	Extension of spring framework
	Spring bootprovides starter templates that groups all dependencies 
	Spring boot does autoconfiguration 
	Embedded Server
--------------------------------------Complete Spring boot app-----------------------------------------
https://www.youtube.com/watch?v=NpdG3lmKJ5g&ab_channel=ProgrammingTechie
Spring boot 3.1 Java 17 Spring framework 6		
#SpringCloud 
	Spring cloud is a project under the spring project ecosystem
	Help to build reliable and robust microservices(develop microservices)
	Spring Cloud provides tools for developers to quickly build some of the common patterns(design patterns) in distributed systems
	(eg configuration management, service discovery, circuit breaker, intelligent routing) 

#SpringWeb
	Build web including RESTful services/applications using spring MVC..Use apache tomcat as the default embedded container 
#Lombok
	To remove boilerplate code
	@RequiredArgsConstructor--> parameterized constructor
	@Data for getters and setters
	@Slf4j
		log.info("Product {} is saved",product.getId());

		
#SpringDataMongoDB
	For product service
#Api gateway
		Acts as a gatekeeper/entry point to send out requests to different services from users
		dont want to give the hostname/ip address of product service/microservice
		As a user you want to communicate with product service
		
Authentication server->KeyCloak
Start by containerizing all your microservices using Docker and manage them locally with Docker Compose for ease of development. 
When you're ready to scale and deploy to production, transition to Kubernetes for advanced orchestration, scalability, and resilience.
docker-compose.yml

#Logical architecture of each microservice		
Http request from clients->Controller->Service(Business logic...sometimes talk to MQ)->Repository(DataAcessLayer)->Database		

#application.properties
spring.data.mongodb.uri=mongodb://localhost:27017/product-service

http://localhost:8080/api/product
{
    "name": "Iphone 13",
	"description": "prakash@gmail.com",
	"price": 1200
}

Multiline string intoduced in Java 14

Controller->Service->Repository
It is a good practice to sepeare dto from model..expose only what is needed
DTO objects are different and model is different
	For Repository
	Student findById(int id);
		Student findByName(String name);
		//jpql
		//@Query("SELECT s from Student s where s.email=?1")
		Optional<Student> findByEmail(String email);
	For Controller
		@PostMapping
		@ResponseStatus(HttpStatus.CREATED)
		@RequiredArgsConstructor instead of @Autowired?
		private final ProductService productService;
	For Service	
		@Service inject repository@Autowired
		
		 Product product=Product.builder()
                .name(productRequest.getName())
                .description(productRequest.getDescription())
                .price(productRequest.getPrice())
                .build();

        productRepository.save(product);
		//log4jfeature{}
		@Slf4j
        log.info("Product {} is saved",product.getId());
	For model
		@Document annotation for mongo db
		@Lombok annotation for getter setter and constructors
			@AllArgsConstructor
			@NoArgsConstructor
			@Builder
			@Data
				Shortcut for @ToString , @EqualsAndHashCode , @Getter / @Setter and @RequiredArgsConstructor
		@Entity
		@Table(name='') if you want to rename
		@Id
		@GeneratedValue(strategy = GenerationType.IDENTITY)
			private Long id;
		@OneToMany(cascade = CascadeType.ALL)
	For Repository
		public interface StudentRepository extends JpaRepository<Student,Long> {}
		
The JPA specification supports 4 different primary key generation strategies which generate the primary key values programmatically or use database features,
 like auto-incremented columns or sequences. The only thing you have to do is to add the @GeneratedValue annotation to your primary key attribute and choose a generation strategy.
		1.1 GenerationType.AUTO
			The GenerationType.AUTO is the default generation type and lets the persistence provider(could be hibernate) choose the generation strategy.
			If you use Hibernate as your persistence provider, it selects a generation strategy based on the database specific dialect. For most popular databases, it selects GenerationType.SEQUENCE 
		1.2 GenerationType.IDENTITY
			The GenerationType.IDENTITY is the easiest to use.It relies on an auto-incremented database column and lets the database generate a new value with each insert operation.(but not the best one from a performance point of view.cannot do batch operations)
		1.3 GenerationType.SEQUENCE
			The GenerationType.SEQUENCE is  preferred way to generate primary key values and uses a database sequence to generate unique values.
			If you don’t provide any additional information, Hibernate will request the next value from its default sequence. You can change that by referencing the name of a @SequenceGenerator in the generator attribute of the @GeneratedValue annotation. The @SequenceGenerator annotation lets you define the name of the generator, the name, and schema of the database sequence and the allocation size of the sequence.
		1.4 GenerationType.TABLE
			It simulates a sequence by storing and updating its current value in a database table which requires the use of pessimistic locks which put all transactions into a sequential order
			
CascadeType.ALL propagates all operations — including Hibernate-specific ones — from a parent to a child entity.
			
201Created response
Integration Tests
#tests products service -- 
#testcontainers..use docker container instances of
#IntegrationTests
#mongodbcontainer
https://java.testcontainers.org/
Define versions for all test containers.. so individual dependency doesnt need mention of containers
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>testcontainers-bom</artifactId>
            <version>1.18.3</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement> 

Now
<dependency>
			<groupId>org.testcontainers</groupId>
			<artifactId>mongodb</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.testcontainers</groupId>
			<artifactId>junit-jupiter</artifactId>
			<scope>test</scope>
		</dependency>
		
23:47 43:		
@SpringBootTest
@Testcontainers
class ProductServiceApplicationTests {
	@Container
	static MongoDBContainer mongoDBContainer= new MongoDBContainer("mongo:4.4.2");
//from the container.. adds replica
	static void setProperties(DynamicPropertyRegistry dynamicPropertyRegistry){
		dynamicPropertyRegistry.add("spring.data.mongodb.uri",mongoDBContainer::getReplicaSetUrl);
	}
		@Test
		void contextLoads() {
	}

}	
//    @OneToMany(cascade = CascadeType.ALL)
For what?
git remote add origin https://github.com/saurabhdcagrawal/shopping-app-spring-boot.git	

@Transactional
	Why? automatically create and commit the transactions
	@Transactional is a Spring annotation that can be applied to methods or classes to indicate that the annotated code should be executed within a transaction. When Spring encounters the @Transactional annotation, it automatically creates a transaction around the annotated code and manages the transaction lifecycle.
	the default isolation level is (usually READ_COMMITTED) and the default propagation behavior (REQUIRED)
	It is a powerful tool for simplifying transaction management in Spring applications. By using @Transactional, you can avoid writing boilerplate code to manage transactions manually, and you can focus on writing business logic. However, it’s important to use @Transactional correctly and follow best practices to avoid potential pitfalls.
	Transactions ensure that multiple database operations are executed atomically, which helps to maintain data consistency and integrity.
	Use @Transactional at the appropriate level: You should apply @Transactional to the appropriate level of granularity. 
	@Transactional should not be used on public methods of a @Repository.
Difference between request param and path variable
	@GetMapping("/foos/{id}")
	@ResponseBody
	public String getFooById(@PathVariable String id) {
		return "ID: " + id;
	}
	http://localhost:8080/spring-mvc-basics/foos/abc
	
	@GetMapping("/foos")
	@ResponseBody
	public String getFooByIdUsingQueryParam(@RequestParam String id) {
		return "ID: " + id;
	}
	http://localhost:8080/spring-mvc-basics/foos?id=abc
	Because @PathVariable is extracting values from the URI path, it’s not encoded. On the other hand, @RequestParam is encoded.
	
	For storing data in table at start..in InventoryServiceApplication
	@Bean
	CommandLineRunner commandLineRunner(InventoryRepository inventoryRepository){
		return args -> {
			Inventory inventory= new Inventory();
			inventory.setSkuCode("iphone_13");
			inventory.setQuantity(100);
			Inventory inventory1= new Inventory();
			inventory1.setSkuCode("iphone_13_red");
			inventory1.setQuantity(0);
			inventoryRepository.save(inventory);
			inventoryRepository.save(inventory1);
		};

	}
#Project restructure New maven module.. to connect all the modules 
		//Dependencies add individual pom
		//Dependencies main pom..add dependency management
		//add parent as spring boot starter
	<parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.0.6</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

		microservices parent pom
		<modules>
        <module>product-service</module>
        <module>order-service</module>
        <module>inventory-service</module>
        <module>discovery-server</module>
        <module>api-gateway</module>
        <module>notification-service</module>
    </modules>
	<dependencies>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>testcontainers-bom</artifactId>
            <version>1.18.3</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring-cloud.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
#Synchronous communication
#WebClient
After you build your docker images in local push to docker hub
Image is downloaded from hub.docker.com (Docker registry)


# spring.jpa.hibernate.ddl-auto=create-drop
	Prevent duplicates when loading

# Inter Process Communication (Rest template or web client, spring boot is recommending to use web client)
	#RestTemplate
		import org.springframework.web.reactive.function.client.WebClient;
		<dependency>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-starter-webflux</artifactId>
			</dependency>
	
	#create config.WebClientConfig in order-service module
	create a bean of type webclient
	@Configuration
		public class WebClientConfig {
			@Bean
			@LoadBalanced
			public WebClient.Builder webClientBuilder(){
				return WebClient.builder();
			}
		}
		
	#Inside order service class		
		private final WebClient.Builder webClientBuilder;
		//check if product exists in inventory
        Boolean result=webClient.get().uri("http://localhost:8082/api/inventory").retrieve().bodyToMono(Boolean.class).block();
        if(result)
            orderRepository.save(order);
        else
            throw new IllegalArgumentException("Product is not in stock, please try again later");

	block will make a synchronous request
	    @GetMapping
		#@RequestParameter instead of path variable
		    public List<InventoryResponse> isInStock(@RequestParam List<String> skuCode){
		From
		@GetMapping("/{sku-code}")
		@ResponseStatus(HttpStatus.OK)
		public boolean isInStock(@PathVariable String skuCode)
	#After Changes(Order Service) (Note you need to duplicate inventoryResponse inside Order Service)
		order.setOrderLineItemsList(orderRequest.getOrderLineItemsDtoList().stream().map(this::mapToModel).collect(Collectors.toList()));
        List<String> skuCodes=order.getOrderLineItemsList().stream().map(OrderLineItems::getSkuCode).collect(Collectors.toList());
        //check if product exists in inventory
        InventoryResponse[] inventoryResponses=webClient.get().uri("http://localhost:8082/api/inventory",
                uriBuilder -> uriBuilder.queryParam("skuCode",skuCodes).build())
                .retrieve().bodyToMono(InventoryResponse[].class)
                .block();
        boolean allProductsInStock=Arrays.stream(inventoryResponses).allMatch(InventoryResponse::isInStock);
        if(allProductsInStock)
            orderRepository.save(order);
    #order
	{
	   "orderLineItemsDtoList":[
		   {
			   "skuCode":"iphone_13",
			   "price":1200,
			   "quantity":1
		   },
           {
			   "skuCode":"iphone_13_red",
			   "price":1200,
			   "quantity":1
		   }
	   ] 
	}	
#Service Discovery Pattern (for inter services configuration)
	In cloud enviroment, we cannot have a static ip address, everything will be dynamic, we will have dynamic ip adress and different ports
	Also there can be multiple instances of inventory service microservice..
	How our order service which understance which instance of inventory service to call?	
	Creating a server which will store all the information of services (service name and ip)
	Microservices at the time of starting will register themselves to discovery server by making a request	
	Discovery service will add this information to its local copy also called as its service registry
	When order service calls inventory service, the order service will make a call to discovery..
		Discovery server will give ip address of inventory service.. 
		It will also give a local copy to the order microservice 	.(in case discovery service is not available)
	Avoid hardcording url of the inventory service by making use of the discovery server
	#Netflix Eureka		
		Comes from different group id
		For the client pom (not from org.springframework.boot)
		<dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
        </dependency>
	@SpringBootApplication
	@EnableEurekaServer
	public class DiscoveryServerApplication {
		public static void main(String[] args) {
			SpringApplication.run(DiscoveryServerApplication.class, args);
		}

	}
	In app.properties for discovery service (We dont want server to register as a client)
	eureka.instance.hostname=localhost
	eureka.client.register-with-eureka=false
	eureka.client.fetch-registry=false
	server.port=8761
	
	For the client pom
		<dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
		
	In client app properties
		eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka
		spring.application.name=order-service
	EnableEurekaClient is deprecated, no need to annotate the main class.
	It is enough to add the spring-cloud-starter-netflix-eureka-client dependency to pom.xml and if we have the application name in yml or properties file it will be registered to Eureka Server.	
	See all services
		http://localhost:8761/
		Application	AMIs	Availability Zones	Status
		INVENTORY-SERVICE	n/a (1)	(1)	UP (1) - LAPTOP-KQ6C3UTQ:inventory-service:8082
		ORDER-SERVICE	n/a (1)	(1)	UP (1) - LAPTOP-KQ6C3UTQ:order-service:8081
		PRODUCT-SERVICE	n/a (1)	(1)	UP (1) - LAPTOP-KQ6C3UTQ:product-service
	To be assigned random port
		Provide port as 0 for inventory service..
		Spring Boot at the time of starting up, will assign random free port in the machine and will run inventory service application in that port 
		server.port=0	
		Allow multiple instances in Eclipse Run Configurations
		See 2 availability zones
		Console log
		2023-07-12T19:33:59.099-04:00  INFO 15052 --- [main] .s.c.n.e.s.EurekaAutoServiceRegistration : Updating port to 58875
		Discovery server
		Application	AMIs	Availability Zones	Status
		INVENTORY-SERVICE	n/a (2)	(2)	UP (2) - LAPTOP-KQ6C3UTQ:inventory-service:8082 , LAPTOP-KQ6C3UTQ:inventory-service:0
		ORDER-SERVICE	n/a (1)	(1)	UP (1) - LAPTOP-KQ6C3UTQ:order-service:8081
		PRODUCT-SERVICE	n/a (1)	(1)	UP (1) - LAPTOP-KQ6C3UTQ:product-service
	#Now replace hardcoded inventory service port and ip in order service
		  InventoryResponse[] inventoryResponses=webClient.get().uri("http://inventory-service/api/inventory",
                uriBuilder -> uriBuilder.queryParam("skuCode",skuCodes).build())
                .retrieve().bodyToMono(InventoryResponse[].class)
                .block();
	#Now test order API 
		Error because there are 2 instances and it doesnt know which one to connect to
		{
			"timestamp": "2023-07-12T23:43:40.855+00:00",
			"status": 500,
			"error": "Internal Server Error",
			"message": "Failed to resolve 'inventory-service' [A(1)] after 2 queries ",
			"path": "/api/order"
		}
	#Client side load balancing should be enabled and order service should try inventory service to try one by one	
		whenever you are creating an instance of your client, you will automatically create the client side load balancer 
		and use the client side load balancing to create the order service while constructing the web client bean
		public class WebClientConfig {
		@Bean
		@LoadBalanced
		public WebClient.Builder webClient(){
			return WebClient.builder();
		}
		}
	#OrderService
	   private final WebClient.Builder webClientBuilder;
	   InventoryResponse[] inventoryResponses=webClientBuilder.build().get().uri("http://inventory-service/api/inventory",
                uriBuilder -> uriBuilder.queryParam("skuCode",skuCodes).build())
                .retrieve().bodyToMono(InventoryResponse[].class)
                .block();
	 #Go To postman and run this on Json	
		{
	   "orderLineItemsDtoList":[
		   {
			   "skuCode":"iphone_13",
			   "price":1200,
			   "quantity":1
		   }
	   ]    
	}		
	After this order placed successfully			
		#Now put discovery Server down and try again
			It succeeds because when client makes a call to discovery server, it gets a local copy of service registry
			Hence it is still able to make that connection (until those local copies are still working)..if they are down, then it will contact discovery server and go down
#ApiGateway
	Microservice environment can have multiple instances and an app can run on different ports
	We cannot rely on harcordedip:port to call the service (external clients)
	Use a component at the start of architectural landscape called API gateway which is responsible for routing the request from users to corresponding services
	onlineshop.com(api-gateway) ../.api/product-->then route it to product service /api/order-->go to order server
	Can also configure a rule for accessing eureka service
	Thus it acts as a gatekeeper for whatever request user wants to make to our system
	Can also help with
	--Authentication (Can contact authorisation server or whatever authentication mechanism implemented - talk to keycloak authorization server)
	--Security
	--LoadBalancing
	--SSL Termination (terminated at the entry point of request.. and internally it will use http request)
✅ Single Entry Point - Clients don’t need to know individual microservice URLs.
✅ Security & Authentication - Can enforce OAuth, JWT, API keys, etc.
✅ Rate Limiting & Throttling - Prevents abuse by limiting requests.
✅ Logging & Monitoring - Tracks API usage and performance.
✅ Load Balancing - Can route traffic based on load.
✅ Request Aggregation - Calls multiple services and combines responses.
	#SpringCloudGateway
	Create a module with
	<dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
     </dependency>
	 Register the API gateway to discovery server
		eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka
	 In app.properties for api-gateway enable more logging
		logging.level.root=INFO
		logging.level.org.springframework.cloud.gateway.route.RouteDefinitionLocation=INFO
		logging.level.org.springframework.cloud.gateway= TRACE
	Define route, predicate and filter	(will do loadbalancing with lb)
	#Product Service Route
	spring.cloud.gateway.routes[0].id=product-service
	spring.cloud.gateway.routes[0].uri=lb://product-service  
	spring.cloud.gateway.routes[0].predicates[0]=Path=/api/product
	#Order Service Route
	spring.cloud.gateway.routes[1].id=order-service
	spring.cloud.gateway.routes[1].uri=lb://order-service
	spring.cloud.gateway.routes[1].predicates[0]=Path=/api/order
	#Inventory Service Route
 By default API gateway runs on port 8080
	#Test with product service
	http://localhost:8080/api/product
	Response
	[
    {
        "id": "649df993b76b9a7e7b956045",
        "name": "Iphone 13",
        "description": "prakash@gmail.com",
        "price": 1200
    }
	]
#See log in API gateway
	2023-07-12T20:45:18.110-04:00 DEBUG 23740 --- [ctor-http-nio-3] o.s.c.g.h.RoutePredicateHandlerMapping   : Mapping [Exchange: GET http://localhost:8080/api/product] to Route{id='product-service', uri=lb://product-service, order=0, predicate=Paths: [/api/product], match trailing slash: true, gatewayFilters=[], metadata={}}

	2023-07-12T20:47:07.188-04:00 DEBUG 23740 --- [ctor-http-nio-3] o.s.c.g.h.RoutePredicateHandlerMapping   : Mapping [Exchange: POST http://localhost:8080/api/order] to Route{id='order-service', uri=lb://order-service, order=0, predicate=Paths: [/api/order], match trailing slash: true, gatewayFilters=[], metadata={}}
	2023-07-12T20:47:07.188-04:00 DEBUG 23740 --- [ctor-http-nio-3] o.s.c.g.h.RoutePredicateHandlerMapping   : [9418209a-2] Mapped to org.springframework.cloud.gateway.handler.FilteringWebHandler@2067b9d1

#Also have eureka server pointed by Api gateway
	#Discovery Service Route
	spring.cloud.gateway.routes[2].id=discovery-server
	spring.cloud.gateway.routes[2].uri=http://localhost:8761
	spring.cloud.gateway.routes[2].predicates[0]=Path=/eureka/web
	spring.cloud.gateway.routes[2].filters[0]=SetPath=/
	localhost:8080/eureka/web should give us discovery information.. however.. because of routing it takes you to 8761/eureka/web when you really just need 8761
		So use a filter	setPath... forward the location to route+set path
		Remove lb in routes
	#Now opens up
		http://localhost:8080/eureka/web
		Comes up without css
	#Only dynamic resources are loaded, for static resources we need more
	
	#Discovery Service Static Resources Route
	spring.cloud.gateway.routes[3].id=discovery-server-static
	spring.cloud.gateway.routes[3].uri=http://localhost:8761
	spring.cloud.gateway.routes[3].predicates[0]=Path=/eureka/**	
	
	Now it comes up properly css is loaded correctly
#Secure microservices using keycloak through API gateway	
	#SpringSecurity
		Secure services /API end points through auth server such as keycloak. Through keycloak we can outsource our authentication and authorization relation configs to keycloak
		Dont need to implement authentication mechanism by hand in our microservices
		Access google or facebook images (connect) from lets says bumble..cannot just give username and password because the app may store this information
		and if a hacker gets access to app db , the accounts will be compromised
	#OAuth.. A stands for authorization	
		Create authentication for our API gateway
		Standard way of providing authorization from service 1 to access another service 2
		It will asked to login into google account.. once you login google will ask you what you want to share..after selecting
		google will store it and send token to service 1..
		This token will now be utilized by service 1 to make access requests to service 2 (google).. token will be verified by google
		Change the settings in google account if you want to remove access
		Token
			Random alphanumeric string generated by resource service and passed to client to be able to access resource
			Client uses this to make request	
		Resource
			Things that need to be accessed( google pics)
		Resource Owner
			Person who owns the resource
		Resource Server
			Stores /host resource( google drive server)
		Client
			Image gallery application.. that needs access to resource in a resource server
			Public Client
			Confidential Client
		Authorization Server
			Generates access token for clients(AWS Cognita, Okta, Key Cloak--open source, Spring working on its Auth Service offering)
		OIDC
			Build on top of OAuth2.. email firstname, lastname//2 tokens...Id token --verify user information and identity of user & access token
		Key Cloak
			Docker can be used.. it will run as a container and you can access the port
			Port 8180
			Set JAVA_HOME
			Go to C:\Users\saura\keycloak-22.0.0\keycloak-22.0.0\bin and .\kc.bat start-dev --http-port=8180
			http://localhost:8180/ user:root pass: pass
			Create admin
			Users in one realm are isolated from users in another realm
			First create a realm
				You can group all your oauth2 clients in a single logical entity called realm
				By default keycloak provides a master realm
				oauth-demo-real
				spring-boot-microservices-realm
				Now go to the realm and create your client	
			Client
				Create spring-cloud-client
				Client authentication on and click on service account roles. Disable standard flow & Direct access grants
				After saving , go to client secret
				Go to realm settings
					get the open id configuration and from that the issuer
					issuer:http://localhost:8180/realms/spring-boot-microservices-realm
					We are going to configure this in our API gateway so it can talk to keycloak server
				# not sure...oauth2-demo-thymeleaf-client
						valid redirect uri: http://localhost:8080/login/oauth2/code/oauth2-demo-thymeleaf-client
						default redirect uri: spring boot will automatically recognize
						Whenever you go to localhost:8080/home... spring boot security will redirect you to keycloak login page.. add username and password
						//access token and id token
						spring-cloud-client# not sure
						User
						Add name 
			Spring starter dependencies in api-gateway project
				<dependency>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
				</dependency>
				<dependency>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-starter-security</artifactId>
				</dependency>
			#app.properties
				Api gateway will talk to keycloak authentication server
				Just configure the issuer UI and springboot will read the open id configuration
				spring.security.oauth2.resourceserver.jwt.issuer-uri=http://localhost:8180/realms/spring-boot-microservices-realm
			#How this will work
				SpringBoot at the time of starting this application will read this discovery document will fetch all endpoints to do the authorization
				and token id endpoint where spring boot can make a call to this token endpoint and verify the token provided in the user request is valid or not
			#config.SecurityConfig inside api gateway project
				@Configuration
				@EnableWebFluxSecurity
				public class SecurityConfig {
					@Bean
					public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity serverHttpSecurity){
						//disable csrf as we are only communicating through rest/postman client
						//exclude eureka calls
						//when we are accessing eureka static resources, we do not want them to be authenticated,,css and java script files
						//for any other calls we want them to be authenticated
						serverHttpSecurity.csrf().disable().authorizeExchange(exchange->exchange.pathMatchers("/eureka/**")
								.permitAll().anyExchange().authenticated()).oauth2ResourceServer(ServerHttpSecurity.OAuth2ResourceServerSpec::jwt);
						return serverHttpSecurity.build();
					}
			#Access the service via postman
				provide a bearer token or jwt token (hit the product service you get 401)		
				keycloak server log
					2023-07-30 09:27:40,030 WARN  [org.keycloak.events] (executor-thread-1) type=LOGIN_ERROR, realmId=34e15427-8cc8-4ffa-8f6c-925767df8df9, clientId=security-admin-console, userId=c05e4bc3-5239-482e-9357-f5ee1a238c31, ipAddress=0:0:0:0:0:0:0:1, error=invalid_user_credentials, auth_method=openid-connect, auth_type=code, redirect_uri=http://localhost:8180/admin/master/console/, code_id=5f614d6c-78fa-4e4f-b4bd-ceb855d371b6, username=root
				
				request token from keycloak by providing our credentials and then we have to provide those credentials to api gateway via our authorisation header and
				type of bearer scheme
				keycloak gives token and then provide that token 
					Authorization
						Type OAuth 2.0	
						Grant Type: Client Credentials
						Access token Url : http://localhost:8180/realms/spring-boot-microservices-realm/protocol/openid-connect/token
						Client id: spring-cloud-client
						Client Secret: Get from keycloak clients
						Client Authentication: send as a basic auth header
						Click on get new access token
						Once you get token, click on use token.. this token now gets saved and everytime you make request it is passed on the header
						Now if you hit product service , you get response 200 OK
		#For Eureka server
			Cannot use authentication mechanism for connecting eureka service through the browser
#Circuit breaker
	Resilient communication between our services in a webclient sync communication
	Synchronous communication.. inventory service maybe down... inventory service may respond slowly.. to the order issue..
	Dont want the request to terminate abruptly
	Failfast and be resilient and we should have some kind of Fallback mechanism
	Circuit breaker :set of states we maintain in our application
		Default : Closed state
				: Open state(throw an error message or send the cached response) and not allow the calls from order service to inventory service for a fixed period of time
				: After some duration the circuit breaker will change the status to half open(sslowly start taking request to inventory service) and it will check if request    
				  are going through. If so it will make the status as closed, if not it will change it back to open
	#Resilience 4j (netflix hystrix)
		Implementation for circuit breaker logic.. easy to use light weight fault tolerance library..newer alternate to (netflix hystrix)
	#SpringDependency
		<dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
	#Circuit Breaker
	management.health.circuitbreakers.enabled=true
	management.endpoints.web.exposure.include=*
	management.endpoint.health.show-details=always
	#Resilience4jProperties
		resilience4j.circuitbreaker.instances.inventory.registerHealthIndicator=true
		resilience4j.circuitbreaker.instances.inventory.event-consumer-buffer-size=10
		resilience4j.circuitbreaker.instances.inventory.slidingWindowType=COUNT_BASED
		resilience4j.circuitbreaker.instances.inventory.slidingWindowSize=5
		resilience4j.circuitbreaker.instances.inventory.failureRateThreshold=50
		resilience4j.circuitbreaker.instances.inventory.waitDurationInOpenState=5s
		resilience4j.circuitbreaker.instances.inventory.permittedNumberOfCallsInHalfOpenState=3
		resilience4j.circuitbreaker.instances.inventory.automaticTransitionFromOpenToHalfOpenEnabled=true
	
		
	#OrderController(same name as property-inventory)
	
	@ResponseStatus(HttpStatus.CREATED)
    @CircuitBreaker(name="inventory", fallbackMethod ="fallbackMethod" )
    public String placeOrder(@RequestBody OrderRequest orderRequest){
        return orderService.placeOrder (orderRequest);
    }
    public String fallbackMethod(OrderRequest orderRequest, RuntimeException exception){
        return "Oops something went wrong, please run after sometime";
    }
	
	http://localhost:8081/actuator/health
   // Status is closed	{"status":"UP","components":{"circuitBreakers":{"status":"UP","details":{"inventory":{"status":"UP","details":{"failureRate":"-1.0%","failureRateThreshold":"50.0%","slowCallRate":"-1.0%","slowCallRateThreshold":"100.0%","bufferedCalls":0,"slowCalls":0,"slowFailedCalls":0,"failedCalls":0,"notPermittedCalls":0,"state":"CLOSED"}}}}
  #Now StopInventoryService- Call API 5 times.. you get fallback message from the fallback method
	Circuit breaker State changes to open
  {"status":"UP","components":{"circuitBreakers":{"status":"UNKNOWN","details":{"inventory":{"status":"CIRCUIT_OPEN","details":{"failureRate":"100.0%","failureRateThreshold":"50.0%","slowCallRate":"0.0%","slowCallRateThreshold":"100.0%","bufferedCalls":5,"slowCalls":0,"slowFailedCalls":0,"failedCalls":5,"notPermittedCalls":0,"state":"OPEN"
		
	After 5 seconds(based on properties in app.properties) it changes to half open	{"status":"UP","components":{"circuitBreakers":{"status":"UNKNOWN","details":{"inventory":{"status":"CIRCUIT_HALF_OPEN","details":{"failureRate":"-1.0%","failureRateThreshold":"50.0%","slowCallRate":"-1.0%","slowCallRateThreshold":"100.0%","bufferedCalls":0,"slowCalls":0,"slowFailedCalls":0,"failedCalls":0,"notPermittedCalls":0,"state":"HALF_OPEN"}	

	Now run inventory service.. 
		Place API it succeeds and circuit breaker gets closed
	
	#Simulate slow response (Make timeout in 3 secs where inventory service will take 10 seconds because of thread wait)
		#Resilience4J Timeout Properties
			resilience4j.timelimiter.instances.inventory.timeout-duration=3s
	
	    @TimeLimiter(name="inventory")
		public CompletableFuture<String>  placeOrder(@RequestBody OrderRequest orderRequest){
         return CompletableFuture.supplyAsync(()->orderService.placeOrder (orderRequest));
		}
		public CompletableFuture<String> fallbackMethod(OrderRequest orderRequest, RuntimeException exception){
			return CompletableFuture.supplyAsync(()->"Oops something went wrong, please run after sometime");
		}
	#Simulate wait in inventory service
		 @SneakyThrows
		public List<InventoryResponse> isInStock(List<String> skuCode){
        log.info("Wait started");
        Thread.sleep(10000);
        log.info("Wait ended");
		}
		Within 3 seconds, order service timeouts	
	#Simulate Retry
		#Resilience4J Retry Properties
			resilience4j.retry.instances.inventory.max-attempts=3
			resilience4j.retry.instances.inventory.wait-duration=5s
		One API request will retry 3 times
		http://localhost:8081/actuator/timelimiterevents
		Shows information about no of retries made
		

#Implement Distributed Tracing
4:21:00
	In a production grid application we can have 1000 of log entries for a microservices architecture it will be diffucult to scan through logs
	Helps to trace a request from start to finish so if request is failed any point of time why it failed and where it failed 
	Use trace id-›unique specific for a request, span Id-›no of trips the request made through the system(a unique id for a given request inside each system..span1, span2, span 3)   
	Essentially trace id has multiple span id's
	
	
	#micrometer tracing dependency 
		micrometer-tracing-bridge-brave 
	#zipkin visualize this information 
		zipkin-reporter-brave 
	#Old
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-cloud-starter-sleuth</artifactId>
	</dependency>
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-cloud-sleuth-zipkin</artifactId>
	</dependency>
		
	#new
	<dependency>
      <groupId>io.micrometer</groupId>
      <artifactId>micrometer-tracing-bridge-brave</artifactId>
    </dependency>
    <dependency>
      <groupId>io.zipkin.reporter2</groupId>
      <artifactId>zipkin-reporter-brave</artifactId>
    </dependency>

	✅ Tracks Requests Across Services – Helps debug failures in complex systems.
✅ Assigns a Unique Trace ID – Every request gets a unique identifier.
✅ Uses Span IDs – Tracks request flow inside each service.
✅ Improves Monitoring – Helps analyze request-response latency.

🛠 Key Components in Distributed Tracing
1️⃣ Trace ID – A unique identifier assigned to each request.
2️⃣ Span ID – Each service call gets a unique Span ID inside the Trace.
3️⃣ Micrometer Tracing – A lightweight, built-in Spring Boot library for tracing.
4️⃣ Zipkin – A visualization tool that displays traces & spans.


Add dependency in all services 
	Download Docker zipkin.io Quickstart 
	docker compose up -d
	
  ## Zipkin docker compose
  zipkin:
    image: openzipkin/zipkin
    container_name: zipkin
    ports:
      - "9411:9411"
	
	Once you add the dependenct by default due to spring auto configuration, all logs will go to localhost:9411
	#For API gateway configure zipkin in app.properties 
		#Zipkin configuration
		management.zipkin.tracing.endpoint=http://localhost:9411/api/v2/spans
		management.tracing.sampling.probability=1.0
		logging.pattern.level=%5p [${spring.application.name:},%X{traceId:-},%X{spanId:-}]
		
			--(We want to send 100% of request to zipkin) 
		Paste in all services 
	#Once you start services 
		INFO [product-service, traceId, spanId] 
		
	#ZipkinUI 
	
	CircuitBreaker creates a new Thread? Thats why you didnt see a call to inventory service.. Disable circuit breaker and you can see all 3 requests in one go	
	If you are using one thread, you will see the requests from start to end 
	To create your own span id's 
	private final Tracer tracer.nextSpan(). name ("Inventory service lookup") try (tracer.WithSpan (inventoryServiceLookup, start ()) { 
	Span id name was the text given? 


#Event driven architecture in microservice	
	Using kafka 3
	2 Services
		Zookeeper is used to orchestrate the kafka clusters
			#DockerCompose
			zookeeper:
				image: confluentinc/cp-zookeeper:7.0.1
				container_name: zookeeper
				ports:
				  - "2181:2181"
				environment:
				  ZOOKEEPER_CLIENT_PORT: 2181
				  ZOOKEEPER_TICK_TIME: 2000
	
			  broker:
				image: confluentinc/cp-kafka:7.0.1
				container_name: broker
				ports:
				  - "9092:9092"
				depends_on:
				  - zookeeper
				environment:
				  KAFKA_BROKER_ID: 1
				  KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'
				  KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_INTERNAL:PLAINTEXT
				  KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092,PLAINTEXT_INTERNAL://broker:29092
				  KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
				  KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: 1
				  KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 1				

	#Spring-Boot with Kafka in order-service and notification-service pom
		 <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artif	actId>
        </dependency>
	#In orderservice application.properties 
		spring.kafka.bootstrap-servers=localhost:9092
	#OrderService (KafkaTemplate clas)
		private final KafkaTemplate<String,OrderPlacedEvent> kafkaTemplate;
		kafkaTemplate.send("notificationTopic",new OrderPlacedEvent(order.getOrderNumber()));
	#CreatedAnOrderPlacedEvent pojo for putting that object in queue rather than simply orderNumber
		For setting default Kafka topic ..put below in app.properties
		spring.kafka.template.default-topic=notificationTopic
	#Value Serializer
		spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
		spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer
		Accept bytes as input from producers and sends bytes as outputs to consumers
		We perform serialization-transform object/data into bytes
		They are used into value and key
		Key=123; Value="Hello World" KeySerializer=IntegerSerializer and Value serializer= StringSerializer
		Common serializer->Int,Float String, Avro,ProtoBuf
	#CombiningAllProperties
		#KafkaProperties
		spring.kafka.bootstrap-servers=localhost:9092
		spring.kafka.template.default-topic=notificationTopic
		spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
		spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer		spring.kafka.producer.properties.spring.json.type.mapping=event:com.shopping.orderservice.event.OrderPlacedEvent
	#NotificationService
		@SpringBootApplication
		@Slf4j
		public class NotificationServiceApplication {
			public static void main(String[] args) {
				SpringApplication.run(NotificationServiceApplication.class, args);
			}

			@KafkaListener(topics="notificationTopic")
			public void handleNotification(OrderPlacedEvent orderPlacedEvent){
				//send out email Notification
				log.info("Received notification for order "+orderPlacedEvent.getOrderNumber());
			}
		}
		#Recreate OrderPlacedEvent class in notificaton servicee
		#application.properties
			server.port=0
			eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka
			spring.application.name=notification-service
			#Kafka
			spring.kafka.bootstrap-servers=localhost:9092
			spring.kafka.template.default-topic=notificationTopic
			spring.kafka.consumer.group-id=notificationId
			spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
			spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer
			spring.kafka.producer.properties.spring.json.type.mapping=event:com.shopping.notificationservice.event.OrderPlacedEvent
		SpringBoot will understand what is the jsonType mapping by providing the fully classified class name
	#TrustIssue
		spring.kafka.consumer.properties.spring.json.trusted.packages=*
	#
	2023-07-13T00:53:12.214-04:00  INFO 28896 --- [ntainer#0-0-C-1] o.s.k.l.KafkaMessageListenerContainer    : notificationId: partitions assigned: [notificationTopic-0]
	2023-07-13T00:53:47.300-04:00  INFO 28896 --- [ntainer#0-0-C-1] c.s.n.NotificationServiceApplication     : Received notification for order efb6fb46-c9f0-4ec7-a973-fb4c94a59210
	Asynchronous communication in form of events
	#Docker
		docker compose up -d
		docker logs -f broker
		docker compose down
		docker logs -f prometheus
	
	
#Dockerize the project
		DockerHub where you will push your docker images once you create them in your local	
		first run mvn package
		Create a Dockerfile
			
			FROM openjdk:17
			ARG JAR_FILE=target/*.jar
			COPY ${JAR_FILE} app.jar
			ENTRYPOINT ["java","-jar","/app.jar"]
		
		Using jdk instead of jre..
		Build the whole image one more time even if you change
		Use layered approach..it will build only files will be changed..save build times	
		Use dockered layer file
			FROM eclipse-temurin:17.0.4.1_1-jre as builder
			WORKDIR extracted
			ARG JAR_FILE=target/*.jar
			ADD ${JAR_FILE} app.jar
			RUN java -Djarmode=layertools -jar app.jar extract

			FROM eclipse-temurin:17.0.4.1_1-jre
			WORKDIR application
			COPY --from=builder extracted/dependencies/ ./
			COPY --from=builder extracted/spring-boot-loader/ ./
			COPY --from=builder extracted/snapshot-dependencies/ ./
			COPY --from=builder extracted/application/ ./
			EXPOSE 8080
			ENTRYPOINT ["java", "org.springframework.boot.loader.JarLauncher"]
		
		#commands
		Go to module.'. give a tag and give the location of folder of dockerfile
			 C:\Users\saura\repo\parent-microservices\microservices-new> cd .\api-gateway\
			 C:\Users\saura\repo\parent-microservices\microservices-new\api-gateway> docker build -t apigateway-dockerfile .
		layeredDocker
			 docker build -t apigateway-layered -f Dockerfile.layered .
		You can see size is much less		
		Containers from java application without docker files
		
		#Use Jib
			TBD
			
			
#Spring boot monitoring
	Monitoring in a micro service project across all services using a data source Promotheus (scrap metrics from actuator endpoints and store in memory db) 
	and Graphana (visualization UI dashboard poll promotheus)
	Spring boot actuator will expose metrics through endpoints(jvm endpoints)... 
	Promotheus will poll our spring boot actuator within predefined seconds and store it in the in-memory db 
	The promotheus will act as a data source for Grafana which provides a UI dashboard
	 
	#Spring started dependences
		spring boot actuator 
		micrometer-registry-prometheus 
		<dependency>
		  <groupId>org.springframework.boot</groupId>
		  <artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>
		<dependency>
		  <groupId>io.micrometer</groupId>
		  <artifactId>micrometer-registry-prometheus</artifactId>
		  <scope>runtime</scope>
		</dependency>
	
	Add in the pom-xml for every service 
		#Enable actuator endpoints in all app.properties
				management.endpoints.web.exposure.include=prometheus 
		Now you can access the /actuator/promotheus end point from your service
		You dont need it in order service
		
	#Add prometheus.yml
		different scrape jobs
	global:
		  scrape_interval:     10s
		  evaluation_interval: 10s
	
	Scrape_configs:
	  - job_name: 'product_service'
		metrics_path: '/actuator/prometheus'
		static_configs:
		  - targets: ['product-service:8080']
			labels:
			  application: 'Product Service Application'
	  - job_name: 'order_service'
		metrics_path: '/actuator/prometheus'
		static_configs:
		  - targets: ['order-service:8080']
			labels:
			  application: 'Order Service Application'
	  - job_name: 'inventory_service'
		metrics_path: '/actuator/prometheus'
		static_configs:
		  - targets: ['inventory-service:8080']
			labels:
			  application: 'Inventory Service Application'
	  - job_name: 'notification_service'
		metrics_path: '/actuator/prometheus'
		static_configs:
		  - targets: ['notification-service:8080']
			labels:
			  application: 'Notification Service Application'
	
	Spin up promotheus and grapahana
		as per docker compose orchestration docker-compose.yml add port add volume --›instruct docker to load from promotheus. ml inside docker container depends on business services, (product, inventory) 
		
	#Prometheus Port 9090
	#Graphana Port 3000 
	Volume /grafana/var/lib Link 
	
	Promotheus: http://localhost:9090/	
		 promotheus UI logback events total 
		 Status-›Service Discovery Status-›Targets .
	
	Grafana:http://localhost:3000/login
	type in admin and password 
	Add a data source-›Prometheus--name as promotheus microservices 
	URL http://prometheus:9090

Take existing dashboard configuration	
		https://github.com/SaiUpadhyayula/spring-boot-microservices/blob/part-10/Grafana_Dashboard.json
	Click on Save and Test 
		Create a dashboard 
		Import via panel json
Import existing configuration--›find a json file Grafana.Json..dashboard..-›import Via panel json test. and your pitotheus dataservices. Switch between services using instance (no hikar1 CP pool for non mysq1 db	

//When you inject a service you use RequiredArgs Constructor